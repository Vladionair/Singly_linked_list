gAAAAABfUPgRJs9EJpwkAKEKNMFK-QQiAywOV6F21bSOHQgzznFMwWm9SzSHNFms7m8y6zkwugBZbPC5p5IP7qsNPVgmhvBq7aRKfgrzqkFjVjOu8W-uDQBCMPlWS3Cj5hgV7TDj_7egIw8SVf72KsS_rqQZU01acPw8pMyCqux9aEEutpTBzS-w_FAchD7aLokh0KBxAxyZ5Gz2vtduOt8nvW0QZ1tMTxsSg75bPq5qgiFlPUD0wGFuj9ArfwZmv-Xi7yY52n9i0jmR9s3zLy9DpjjTdR-I3_P8Dwf9E3-zxe-UBcBexJ-hvCcaPPn25dCmRGIo-X-19ZdRsZBATv2qeqJpccoij12wmUaZRg1d5TKj5eGMRlyUhdA3aUi3crF89E1IC0pBQvNri8Dj8HYqnqUEq7kczkJbSce363tA6-GkXfxwkp4LGguOO08KYGwcmw40Z0qlX9BkrxWtXplojOed6pYrrHL9nhD_XHYNFSDtqO7mw8nn_ZKXvHg7-bUaJwyrSjHftJokZ_0cLNQ7_8XHAZzxf1IMA6brONlW_Jum07oU-uiPbnKcXibtjXI-clbCzqXj5vyi_6FgcFfCL9oB-2hM44y9-Xesv7-3VUIHfMDHIoMbN8-G-1Kh0mwbjY3FncLtE1sVkM0t3IkD_muiColBvIxOOrIZ3ll9r3TSNKMm-qsRWb-4h5Qeo3MgBNZJ9AZlmP41RxaiuJL0emnvp3VJvwGCARv2QP5IohTfhnbm1M6xHPgJxdCpRzeNXJmxwNv11-H8I-1lYe6HvjF3FHixq8XZWultBv36rR7aSKRmNe61PeU8zzv8C4d3Bln8fk62idIYUYNQmWSMl4CPFL-vYJrKB51JruDnURNLiB17VojSbjkJTqtzai4id1SRcKIqLoS0GaRd4l_82Motkw7BLJpCjA2ZbldJeNm8Wn0du5swgdH7X1akZBGQ_Z81lPbvraiC-VqLEwYxG4jgd5aAX7LPYkAPqqMe_TN08TxHMrQbmWYNBEgk04c36HnitD6nAvk_AOuebc25_MfSPCMisn3UT3nKjqnMn12B9gzwnaG5v-F_xsYl0zSiSCVJR5Kml9AxaKxj4X3ZABfpajZGlUwCi9JUyx8V1T38MOAdJSKvB3fGeRKwbJAN9w6mZ8rjc0Z3_JLDHCn4RBP3A5o4lBeGl4okL9brSWQyIzWI7UBy5UUtV8G2u1JmX3rSA4p10vM8AKxZ7DSCpahqlP_nqGoEUrJyRkAmis1On0cAW36cSz770bBAkHeqQZvugSd6nfsyaQPKI8bSU-19LvmCcPycb0AEv78cXEIxi96yaLKXsyjJL2EiMG-S-YMFKqDDGz_VCS0krarG3ej9H4lUq1JBRopaNX2mYjktdGXb1As3ZqFZuGh2wdhrHo1RZnJRydgLnOJGctXrRu9szDNrjUYRKaPQkr9PiFKgLGAy3LZhzea_NQXe9pjat4xGqAJE0OKaknjzaRrzrLch5klg8BslCopbCuxtkpNQB6dmUtq7AKoD41oxtouUoUiYVwU3wl0SeQDdsfQkKscvajtWhuTolkvoAj77qtQDi7N_ewdKyP0tXo8cik5UmuFKU5klsbmAWPsgci3G6L-AXSmSxgZrIMQZUoPTpf0hDKllf0ZGeyhSWbPRSAp_E0to9MiYhUGxtFFqrBADg7J0f1r1MlbdyQrSVQl7hnqAUABNXV2wOWJaB5Sy-YMzKAvrNKwakvKMqxGTNsWFklNMSaJJZo32GERln7XG1jGy443saP8_soUMhRXVaQ4xI4z7G3D6CWRGNqicQ7hL4rVfIFMdXKvDT9vKAeaTvJiuCx-OsgbChLx6TqnPeG5j5LEK51avxYBtj8zCRu4G8Qop14QVAEbIcwoActdJHTl3jc69iFrgp52iRiyRYuHxxLof-ePSE8CU71MI80TjdmhnIJaWuHLMimx9S5VQQ-Zl1QODFW3H6WTypmUm0SQlyigT_jNHhX3e4ZBksHduYZUrt71hUtWPIJ57-cDlwL3O2kHVtaC7eXGjJlClpvw0CS7pppUeFvt6TL4LY7zjdxrsVNxqQS9lsn2Olec794OvaXlxHagYd1r1H-8p8Gins2L1ofPu98k5UtjZisO3bYBcD1MNrgaM7PP5bumeNvr6k3UPWy0xypduWIHh5DPDoIUAQuNq7LPULkK5KqLYpiOtOAFf0vxu2Cn9-2ufFSzIJRyiY6EHF-G5zUvGU_bz9kJ6qLUEPZppq6-n1khmZ46ZvvTcf5pI4pes9f5ls0_OzcZrd_iGcvE6snaBatU0R54pXxLeFMS-otC9gbCEI4EPsAbcvKK8emgoQ-98w4t6eqMh0eSWrOsXMJu4ETKxDvQcc13aV0etJo7kpX_ypiyOpQpjYbu5LaaGd5t0M6mdINIaTqBsmD2KvFydEfOjFh3divRjTpOHv5M0Tff5J_nQ52fN1yDhMWYbRgfNVAiwvNbnWYVQTHbtSEegjINAj4RfDwWeURol-m7oGSWu2LYvkh49QHW69iNvUs1i1gbaLhrZuoHWuYq0c9e8PcKPnGKjQ718s5oKxBmR9S7tJqtrIZGhkisbXOXB7zjS7HZpJPcUAozY86dqlJ-OsguYJY3ynKo5TJRNMD3r4jW4i8nPo-ufy3yoeo7bQ1UI9mSYaF-cySPOx-GOkPNC3y6sC5CHLSX2jMArsg2GJvhtOALi9RJ4qNvHiupGyFJuyWts-QUnsAZs5ZizgwYM5sVZxh6uPL-s05BYa5HjpWJ3aj0-vJdqjkSDoSPEC0W7oJXDpiCvSGTHtQG4X36PJf4bwpAs1ZyuId_YMDaRHf7aTrUdJdDcB3IziV8omDimV7jGPieY0h77VsYjYAQz-OfWbGUjL1JpO4n0cHTIMohLYE6jlkRBX7L-PLprBQaIWlhn7XFZdH0-89QOSif6ZxuF5oua4XIztuj1P3XZlGI5CSIsL9GjKWKYVK7YCf38MjbdO8TICqg5n4kg6mXgj4M6y9mf3typRbM3jUeD7l1TH4qYdsufk0zdOdOpE619OL3UYn36gEry7Iij92OBnd9LTCf7yBFuSCoukonnYaQv2DR0DMu4ZbcCCqt_ymbmwA8gaXuR48My_UrZtom4ItASkxlIMI1MAAhS-GEleWWzUyVU48TmYlzWKQi9J6XHFn6G1-AE_0aIADjmrfgWt-Qm1oUYkGlqbRDS6M_Dz4bY-P9q3BSMmKJMTYk21UjPngLGQDffBvA_mVMcqzuh9aMBc9occvNesABYTiuH4RDKVbfYHlDgAXZxQHIEyLjEoriPl4XdFwd81pBv9Qe_DyHxObuB4epo4OnfhBsdGySsyP5087-lE1xI6nRTQgaooBDXqMknWqjJ-xwkZKttIJ13jMDUy1O32SswfiinXS2xsT5FFYE2L2MgdzKrOn7dAs-pJiWIENl3T35lkXNr4tEEo1lEZLpab78yaiewKj_skqs2rzJ64pxCmu1jm0hdz2kZQgHlP1NHJkrmzThvNO2G4uVZGz8I5Cq0Z_iVFSy__H4HTwRiSGMSCZwI3Zi4ZyjpVj24YTpraOuvHDbe5prBm7JmjJERtIRmUJitBxi8EyMj5MoTmxHSxeETj-jYCihq10lxROONilORGlqrB9mhh2dILSi9vSC8x23WwLs0iOdEpDIDQySvM0C34kw-NUagHiDbOcXoAZUpZXiP-dp7AR5N0UMV5Z6APPL8n6gQ_8ruHIkTqswLzFuswGzfXwluUMfwmHqpJCLxW9y8DbFzGgzzZlmgu9ry0cSiC5Ino4BSfTSNh5pfeYq_-ajhV3TM3A04LwKAm_Cuf83YhgAGuOPR3jufCq4QPeh0IXwOCvhdFDNhSNmFf6Y4bRtJCRmNdF4if05Q9uzyDlGKGcK4zUlB8nJ_0GOH7LTLLMJNHqu38BN2hMiBwqOPVu-TuYvyBCQzbDx0OpOOMFiZH0caBlItYO6n00E9fqcn_4DcaOGV156om4K6EKukFxOBYXapsHK9f3LJsRnByeN8Qk-3eTtLYejH1rKqBn3_ThZBg9Ja3wCqhWPv7617Wg6nD6TDxnFuidpO7Z5KtaVqGiIhANbpF0Qgbmx_kVLnrJFrKaACLU_q3nI7L5QN8E_D0NtOGcPOriXn4eWOUOqKaI3E2lgSOITD-13nuVAaQlCS10IfLq5vgwP3SJN1kEbw_NafZ00vTBWDBxI-enKaGkrBxGFzCLCh2j6u87xSvWxEN9kenPSaPKB7IijW43MTgRBCvChp9MZluUw_WC9nzIFOYli3vUq5PlRaAAMy-BBwxnCYTQ_pU2zcN0-O8GLJ488rVi56rkP97dlGijFcQqxePn_H_TWrsJK5APumaixP1aj86W7lnSw2stmBrQ4d78t2tSMmgGE4zLJZzcZxncbxm0BckyJdtcIr7NxEI9s1mK21IWgiEiLm6ufphffEHIDZMriSDKn3zyyLG4reuO-smmVBXV7zcmZYcw6jufHW7WnA9On6IorCiv9nER-lptKseMmoV0ID0s2WL1Che5mQV93RfANg0LLJfPfdJ7DVYc7nzv3qxGbz_JD9n_nauAsRbatsv8aZmY8GWfZQpjDnNxuAiPvOaQ9LI6zyG6eKwnAVH7qk79-CQX9d7oEWXnbkuNlxWtMqIeNXZSQokLHbvd_8xNbtym0zKEQmtm2UJg73PQtMs56YYddVfthgEnO3aaj3O1Zudu-bzejulZAfp-dEV_h5_LQI-ldpgS6iT5qIV45rVK45rcIUJhCJkZB4mhzy3H8TkniPI33QDQZQDWfFeJLYDJivAOz4V3aEqWEtDa22-6Jv-Rc8N0WHVw5FgQlxgB01sYxXqamAlor3ZUXZvOPQla092A88q0XUUWR5tCbmhG90qsfH2rFg7kev-_WxaHpvQe3YSwqcYHVracsieGGB6r7IG0dllcEKzlJreNph5IuvyThzS2hl69jeXdvKYpl47-FZmgA2GxWkkHyySS48FzGbEZr6IRCjQUrDsR12U8fMUvDkDsJm1PFbmXkjH3Scbs55UQVnlWECcD-XPT124dP2YGyYtjRP7IjdG8U4E1Qxw72NOlk_ikbGdHCq44T7hRMJOXPYMLQvV-U3u8JoDR0fjaoLZbnojB9s3L7NkDRbiQHN6pEgRI17RkmSPsf2_-u4MyFCJDh5I4nY8nn-2-l4G0xEsAa201yMvzRHa3ChQn4GqtHk9mHDOK81C2fCwBM90CHVYZ4zCIV3jvj8CLkKByVeh3UrM7uhxgikkhl_BeGYzDJg0klyo1bDnEX12k6FZEYlRgg8zj36uos3CSmKfMQ5yDU7AZpWWfz9v5oImpmE9g4NYRQoU7Rpn-65VG3rPMA5GZQO905lZtH24TZvnKhCetjXyUx2ddk3mzR8c6Uz7qYacZpplcygIJpVXRcl9Wi7STgmJ7IGb9w0QeiBymVhnOMOkDMXZ-KKU_1CtPVcyN-naVGnxE22BS-lre_1vp9aszA0dkGJ_yhu84ort3ztHc0L6dcs46jTlawwhWqGdrJLV65mPEas7DcDewSeW60cg1rcvcrYH1LI4r9HRcr0Udu3sHRQUW-uRRjng_vxrPzn2ySy5P73p9rA7W7K6IDVuW_1XO3g-2vIVaFt8hyChMTVOelh8bpZ0uanY-edNcuEutbHy_9mxcFzEIBO7yY0u-pn0vLoyyDHEZKj1nrKA-L2wb9dKkVHnlu3-C06sDzp7m6hbOyXgCr1rxeJ320XS4unlMn5TidkakjmQ6rLl1fMBiKsoCf9K5ms7sE2DX5e3F8XsePEz8fNkm8tpftLazE5jRvuB2hWEKg7XVOSAb1zZjT47EHTvFdanm3WPBPb7FUgfe5mKqca7Z04UXktecNVMl_0_dByJdy5fBCYuFWzWDyqg6go1GCpfyjSpp1hOBuzy4BTKkZFOIPwGWwTCHVlW0J0bMT5XnZLahc93dwHIZK2ZjHYGvO3us-229_dkzPLpxRaAyIuzyPg02lf6-qhrwly5pIsbMbIRdwS3aMgjsMaSxZgmafTDd3aA3sZShsLQ7505NuBXykhtXvvvkvmcQbQGkkxQ4NEiFTr-skGCJQqQaC99loYY403M1XkNyhTJSPu0ZKjSyHBqIshUpvougYtHhJwG5ogHw4kRY2MtX1JY4i3PxoYRh5AD0MmJazMjatJbPF3xHApH_mGWfNjMx1Iarh9RIzEjS15XS9JeVUCcZAoUDHZcWysqnQXVjI4YHwdDURmkd0NwE2Obpp-QlX5Vls2k7nQwvrrSZvv8h3AjHtXXbheQEAJnQlfepoMDesZ53e5B6VvZbRN0Y55XoLf3p7UKi_xzmrbDO0mIg_yAVr0YJ9ph1A70bda8HwNzlJEaLTRlZnZAtMgpzJm4RWRrgP7Gz7ShvJV1dolaoV97f0pHrStyiSzoWlmNdblXYAe9BQS6f97bUdm5PKGODF9NoXhIEFQpwvlTylq_MNPzbV6IxyuuUNV6Jl4MRQMXYSUM-sYQz_HHD-SsBJ11jsPyNjmO6z86gA5NRHNW3ydxH4vwUHTULcGrrG8V1H1-9IZEBXEI4l7E7k9ylBtlTzGp2BVCpPTAMCsT9yeOZQ523m621wA7L5A6B_pakpFZs50Wp_KFZPs4c1rL4fhIJSoOjDbaDS01ADM3dwQ4i3e9FOHRDqC-iBms0hHukzIPGfqSMLXmMbKvABhtzVT2DgtriOovWUq9Yd_xvLYkNKyO4lhIo7paXoaRT0L4d3e_ZlkdTIcBDdH6cVKYgm6cEDAZ-6muTetaKCmIF0wEuakmJcao9qABI6t8_E2HvMAJD4HjlAmbAI7SFgfeSoRkPsckxOkfgEJxlMAfalPnt7XqTXYZSiDCOG5Dq_MjouaY0QaNxdaNiED2jjI47cA1rGIO5GyESM6luP2dwnDHvdKGojIJQP1HP8Z_Zc6I00K44WL4ZUafr_8ZZ7LwZVSQR_nm4toYvzM7uTU5pYj6c21TwIi_N-nd1pmnHvuMfuYBF-psAGNjgujLwY18W8RsqHlZsaAFF9nA9XcwI_ufDpZp7bM69gzDs_yLWG39foWkXLYfs2IZemdLlRIKSaYmzmxbjoV1KQPJQ5pD9vMIzK0iZ7LJ_dxF73ccTJXZUW4wtrubDcMCA6NZ80L1jaJvEY4EE7YM0iur2dpVKK3UQGnxiiaO19tpyec9Rm6mKv7qpA8JAP2kP27Cdt9bHjAe2r7nv-4RY7c3qGq4D1qEnt6FTR-G9GzOTJYCHpN60x1DJfaoyBODwFD-CXj7q4I-yvRd-FRBf-sw-xOA1Of8mLuJ4lafetNZJ7-O2eks760MAMXCju7PWGF9I_NEgS2JVPV-_YECYIusjyYbS_zXQQa1m_7zTbeweEEV_MiDkB5Z_aMhrP_7FEGRpiclgoIVoSSrdq5L1Mth1bntBo372pRnqM6QfogUFswN5fYCeF9k-tCMuNG9aXsafFAPq7xiIvmYAVrYoDcwRgxXLi-pF2-KRadsZ-w_qE-g2Brxg-5avFsfhOYJOCqSS9wU8HeO2IBgCph2BqGN-rJ61TXG-rwbcp_Fs4qKVfb0A6ejYo1Y2EmqH0xm-LqeYzLKQf8p94RpHzvLwevvFjDRWsgwlDQIQlG-ojenbI3q-Pg7_vw5NFHv0ObDeWdH_qfp-SUk_Cm1Lu-G9Cqsb8HGFI1Jtov5PYcEzc1atGaKFQDg_jQYFl51xvqgvPfx3RSO-Ar2zBEcjEoKWbSm-HAjr2P4fDq16kLpJ25-D6yvsrlkniXgysFwrnHBFNtt51ycgfyux-azp3xRvW_II85pwq8BTEjdmHkhwNhagNwLMxTWq-yobIEHf4=

class Node:

    def __init__(self, value=None, next=None):
        
        self.value = value
        self.next = next

class LinkedList:

    def __init__(self):
        
        self.head = None
        self.tail = None

    def add_in_tail(self, item):
        
        if self.head is None:
            self.head = item
        else:
            self.tail.next = item
        self.tail = item

    def print_all_nodes(self):
        
        node = self.head
        while node is not None:
            print(node.value)
            node = node.next

    def find(self, val):
        
        node = self.head
        while node is not None:
            if node.value == val:
                return node
            node = node.next
        return None

    def find_all(self, val):
        
        listing = []
        if self.head is None:
            return listing
        node = self.head
        while node is not None:
            if node.value == val:
                listing.append(node)
            node = node.next
        return listing

    def delete(self, val, all=False):
        
        if self.head is None:
            return None
        else:
            old = node = self.head
            while node is not None:
                if node.value == val:
                    if self.head.value == val:
                        self.head = self.head.next
                        if self.head is None:
                            self.tail = self.head
                            return
                        if all is True:
                            continue
                        else:
                            return
                    else:
                        while node.value == val:
                            node = node.next
                            if node is None:
                                old.next = node
                                self.tail = old
                                return
                            else:
                                old.next = node
                                if all is True:
                                    continue
                                else:
                                    return
                old = node
                node = node.next

    def clean(self):
        
        self.__init__()

    def len(self):
        
        length = 0
        if self.head is not None:
            node = self.head
            while node is not None:
                length += 1
                node = node.next
            return length
        else:
            return length

    def insert(self, afterNode, newNode):
        
        if afterNode is None:
            self.tail = self.head = newNode
            return
        else:
            newNode.next = afterNode.next
            afterNode.next = newNode
            if newNode.next is None:
                self.tail = newNode
                return

import unittest

class Test_LinkedList(unittest.TestCase):

    def test_delete_false(self):
        
        List.add_in_tail(a)
        List.add_in_tail(d)
        List.delete(1, False)
        self.assertEqual(List.head.value, 1)
        self.assertEqual(List.tail.value, 1)
        self.assertEqual(List.len(), 1)

    def test_delete_true(self):
        
        List.add_in_tail(a)
        List.add_in_tail(d)
        List.delete(1, True)
        self.assertEqual(List.head, None)
        self.assertEqual(List.len(), 0)

    def test_clean(self):
        
        List.add_in_tail(a)
        List.clean()
        self.assertEqual(List.head, None)
        self.assertEqual(List.tail, None)

    def test_find_all(self):
        
        self.assertEqual(List.find_all(1), [])
        List.add_in_tail(a)
        List.add_in_tail(b)
        List.add_in_tail(d)
        self.assertEqual(len(List.find_all(1)), 2)

    def test_len(self):
        
        self.assertEqual(List.len(), 0)
        List.add_in_tail(a)
        List.add_in_tail(b)
        List.add_in_tail(c)
        self.assertEqual(List.len(), 3)

    def test_insert(self):
        
        List.insert(None, b)
        self.assertEqual(List.head.value, 2)
        self.assertEqual(List.tail.value, 2)
        List.clean()
        List.add_in_tail(a)
        List.add_in_tail(b)
        List.insert(b, c)
        self.assertEqual(List.head.value, 1)
        self.assertEqual(List.tail.value, 3)

    def tearDown(self):
        
        List.head = List.tail = None
        a.next = None
        b.next = None
        c.next = None
        d.next = None

if __name__ == '__main__':
    
    a = Node(1)
    b = Node(2)
    c = Node(3)
    d = Node(1)
    List = LinkedList()
    unittest.main(verbosity=2)

class Node:

    def __init__(self, value=None, next=None):
        
        self.value = value
        self.next = next

class LinkedList:

    def __init__(self):
        
        self.head = None
        self.tail = None

    def add_in_tail(self, item):
        
        if self.head is None:
            self.tail = self.head = Node(item, None)
        else:
            self.tail.next = self.tail = Node(item, None)

    def print_all_nodes(self):
        
        node = self.head
        while node is not None:
            print(node.value)
            node = node.next

    def sum_lists(self, list_1, list_2):
        
        sum = []
        node_1 = list_1.head
        node_2 = list_2.head
        while node_1 is not None:
            if node_2 is not None:
                sum.append(node_1.value + node_2.value)
            else:
                sum = []
                return print('Lists are different!')
            node_1 = node_1.next
            node_2 = node_2.next
        if node_2 is not None:
            sum = []
            return print('Lists are different!')
        return print(sum)

